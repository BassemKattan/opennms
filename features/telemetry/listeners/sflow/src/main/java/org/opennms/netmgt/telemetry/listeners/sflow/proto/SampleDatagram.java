/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2018 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2018 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

package org.opennms.netmgt.telemetry.listeners.sflow.proto;


/* Header information for sFlow version 5 datagrams

   The sub-agent field is used when an sFlow agent is implemented on a
   distributed architecture and where it is impractical to bring the
   samples to a single point for transmission.

   However, it is strongly recommended that wherever possible the sub-agent
   mechanism not be used. If multiple processors are available within a device
   the various tasks associated with creating flow and counter samples can be
   distributed among the processors. However, the agent should be architected
   so that all the samples are marshalled into a single datagram stream. The
   final marshalling task involved very little processing, but has important
   benefits in making the overall sFlow system scalable. By reducing the
   number of UDP packets and packet streams, the protocol overheads associated
   with sFlow are significantly reduced at the receiver.

   Each sFlowDataSource must be associated with only one sub-agent. The
   association between sFlowDataSource and sub-agent must remain
   constant for the entire duration of an sFlow session. */

// struct sample_datagram_v5 {
//     address agent_address          /* IP address of sampling agent,
//                                       sFlowAgentAddress. */
//     unsigned int sub_agent_id;     /* Used to distinguishing between datagram
//                                       streams from separate agent sub entities
//                                       within an device. */
//     unsigned int sequence_number;  /* Incremented with each sample datagram
//                                       generated by a sub-agent within an
//                                       agent. */
//     unsigned int uptime;           /* Current time (in milliseconds since device
//                                       last booted). Should be set as close to
//                                       datagram transmission time as possible.
//                                       Note: While a sub-agents should try and
//                                             track the global sysUptime value
//                                             a receiver of sFlow packets must
//                                             not assume that values are
//                                             synchronised between sub-agents. */
//     sample_record samples<>;       /* An array of sample records */
// }
//
// enum datagram_version {
//     VERSION5 = 5
// }
//
// union sample_datagram_type (datagram_version version) {
//     case VERSION5:
//         sample_datagram_v5 datagram;
// }
//
// struct sample_datagram {
//     sample_datagram_type version;
// }

import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.opennms.netmgt.telemetry.listeners.api.utils.BufferUtils;
import org.opennms.netmgt.telemetry.listeners.sflow.InvalidPacketException;

public class SampleDatagram {
    public final static long VERSION = 5;

    public final static int ADDRESS_TYPE_UNKNOWN = 0;
    public final static int ADDRESS_TYPE_IPV4 = 1;
    public final static int ADDRESS_TYPE_IPV6 = 2;

    public final long version;
    public final InetAddress agentAddress;
    public final long subAgentId;
    public final long sequenceNumber;
    public final long uptime;
    public final List<SampleRecord> samples;

    public SampleDatagram(final ByteBuffer buffer) throws InvalidPacketException {
        this.version = BufferUtils.uint32(buffer);
        if (this.version != VERSION) {
            throw new InvalidPacketException(buffer, "Invalid version number: 0x%04X", this.version);
        }

        int addressType = (int) BufferUtils.uint32(buffer);
        switch (addressType) {
            case ADDRESS_TYPE_UNKNOWN: {
                this.agentAddress = null;
                break;
            }
            case ADDRESS_TYPE_IPV4: {
                try {
                    this.agentAddress = Inet4Address.getByAddress(BufferUtils.bytes(buffer, 4));
                } catch (final UnknownHostException e) {
                    throw new InvalidPacketException(buffer, "Invalid agent address", e);
                }
                break;
            }
            case ADDRESS_TYPE_IPV6: {
                try {
                    this.agentAddress = Inet6Address.getByAddress(BufferUtils.bytes(buffer, 16));
                } catch (final UnknownHostException e) {
                    throw new InvalidPacketException(buffer, "Invalid agent address", e);
                }
                break;
            }
            default: {
                throw new InvalidPacketException(buffer, "Invalid address type: 0x%04X", addressType);
            }
        }

        this.subAgentId = BufferUtils.uint32(buffer);
        this.sequenceNumber = BufferUtils.uint32(buffer);
        this.uptime = BufferUtils.uint32(buffer);

        final List<SampleRecord> samples = new ArrayList<>();
        while (buffer.hasRemaining()) {
            samples.add(new SampleRecord(buffer));
        }
        this.samples = Collections.unmodifiableList(samples);
    }

}

